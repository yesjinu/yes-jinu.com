---
title: 데이터베이스 개론과 실습 part 2 (2/2)
date: 2021-07-20 23:07:04
category: dev
thumbnail: { thumbnailSrc }
draft: false
---

쿼리를 작성하는 부분은 데이터베이스의 인터페이스를 조작하는 일이다. '데이터베이스 내부 사정은 모르겠고, 이런이런 값이 필요하니 가져다다오'랄까.  모듈화된 프로그램을 이용할 때 대부분의 경우, 내부 구조를 몰라도 상관이 없어야 한다. 속도감, 효능감을 위해 내부 분석을 전략적으로 스킵하는 것도 방법이다. 하지만 자신의 주무기가 되어야 하는 툴이라면, 내부를 한 단계 더 들여다보는 편이 좋을 것이다. 주무기를 자유롭게 사용할 수 있는 상태가 고수가 아닐까.. ~~하는 초심자의 추측~~

지난 ch2 (1/2)에서 실제적인 쿼리를 작성하는 법에 대해 배웠다면 후반부에서는 조금 더 개념적인 부분을 다룬다. 가상 테이블 뷰(view)와 인덱스(index)가 그것이다. 책을 중심으로, 인터넷을 통해 찾은 자료를 덧붙여 정리해보고자 한다.

## 뷰 View
### 필요성
서점을 운영한다고 하자. 서점의 매출 정보나 고객의 취향을 분석하기 위해서는 다양한 보고서를 만들 필요가 있다. 예컨대, 일별 매출 정보, 고객별 판매내역 등의 테이블이 필요할 것이다. 이런 정보들은 하나의 테이블에 집중되어 있는 것이 아닌, 여러 테이블을 혼합해 만들어야 한다. Business insight 라는 것은 하나의 테이블로 뚝딱 유추해낼 수 있을만큼 쉽게 얻어지는 것이 아니다..

그럼에도 불구하고 대체로 정해진 조합이라는 것이 있을 것이다. 예를 들어 판매 정보가 담긴 order 테이블과, 고객 정보가 담긴 customer 테이블, 책 정보가 담긴 book 테이블은 서로 `join` or `sub-querying`되어 사용되는 경우가 많을 것인데, 매번 작업할 때마다 이 커맨드를 입력하는 것은 매우 번거로운 일이 될 것이다. '이 조합으로 만들어진 테이블이 있다면 얼마나 좋을까?'의 화답으로 만들어진 것이 뷰(view)다.

### 뷰(View)란
뷰(View)는 하나 이상의 테이블을 합하여 만든 가상 테이블로, 실제 테이블처럼 사용할 수 있다. 신기하게도 뷰는 디스크에 테이블 데이터를 따로 저장하지 않는데, 이는 뷰를 생성할 때 사용한 `SELECT`문의 정의를 DBMD가 저장하고 있다가, 쿼리를 처리할 때 이를 참조해 사용하기 때문이다. 즉, 유저가 뷰에 쿼리를 날리면 DBMS는 뷰의 정의를 참조해 쿼리를 수행하고, 그 결과를 반환한다. 유저는 뷰의 정의를 알지 못해도, 마치 그런 '테이블'이 존재하는 것처럼 사용할 수 있다. ~~(혁명!)~~

하지만 뷰에도 몇 가지 제약사항이 있는데, 테이블의 정보를 조작하는 DML 쿼리의 경우 '경우에 따라' 수행되지 않는다 예를 들어, `UPDATE` 키워드를 사용해 특정 속성을 업데이트할 때, 기본키를 포함하지 않는 수정 요청인 경우 수행되지 않는다. 또, 2개 이상의 base table(조합에 사용된 테이블)의 속성을 포함하는 수정 요청 역시 금지된다. 이 경우 `PLAN`을 이용해 쿼리를 실행해보고, 문제가 있는 쿼리인 경우 실행하지 않는 방향으로 구현되지 않은 것이 의아했다. 🤔

### 커맨드
1. 생성
```sql
CREATE VIEW 이름 [(열1, 열2, ...)]
AS SELECT 문
```
여기에서 '이름'은 뷰의 이름이고, '열1, 열2, ...'는 SELECT에서 추출하는 속성과 일대일 대응해야 한다. 예를 들어서 설명해보자.
```sql
CREATE VIEW V_Book_Soccer (name, id, price)
AS SELECT name, id, price
	 FROM Book
   WHERE bookname LIKE '%축구%'
```
이 쿼리를 수행하면 `V_Book_Soccer`라는 가상의 테이블이 만들어지고, 이를 일반 테이블처럼 사용할 수 있다. Base table인 `Book` 테이블에 새로운 '%축구%' 튜플이 추가된다면, 이 데이터는 `V_Book_Soccer`에서도 조회 가능하다. 
2. 수정
테이블의 스키마를 수정하는 것처럼, 필요한 경우 뷰 스키마 역시 수정 가능하다.
```sql
CREATE **OR REPLACE** VIEW 이름 [(열1, 열2, ...)]
AS SELECT 문
```
3. 삭제
테이블 삭제와 마찬가지로 `DROP` 키워드를 통해 뷰를 삭제할 수 있다.
```sql
DROP VIEW 이름
```

## 인덱스 Index
### 데이터는 물리적으로 어디에, 어떻게 저장되는가?
 DBMS는 유저가 만든 테이블을 디스크에 저장하고, 쿼리에 따라 검색을 수행한 결과를 보여준다. 그렇다면 DBMS는 어떻게 데이터를 저장하고 검색할까? 일단 물리적으로 데이터가 디스크에 저장되는 것은 자명해보인다. 데이터는 디스크 혹은 메모리에 저장될텐데, 전원 공급이 중단되면 데이터가 유실되는 메모리보다는 디스크에 저장하는 편이 더 안정적일 것이다. 우리가 워드 파일을 `.docx` 라는 특수한 확장자를 가진 파일에 저장하는 것처럼, DBMS 역시 고유한 방식으로 데이터를 저장해 관리한다. 

MySQL의 저장장치 엔진은 플러그인 방식으로 선택할 수 있으며, InnoDB 엔진이 디폴트로 설치되어 있따. 저장장치 엔진에 따라 데이터를 저장하는 방법에 차이가 있는데, innoDB의 경우 테이블의 형태(`frm file`)와 내용물(`ibdata`)을 별도의 파일로 분리해 저장하고 있다. 

### 인덱스와 B-tree
인덱스는 원하는 정보를 빠르게 찾을 수 있도록 고안된 데이터 구조다. 특히 데이터베이스에서 인덱스랑 원하는 데이터를 빨리 찾기 위해 튜플의 키 값에 대한 물리적 위치를 기록해둔 자료구조다. 일반적으로 인덱스는 B-tree 구조로 구현되어 있다. 

B-tree는 balanced tree의 한 종류로 데이터를 크기에 따라 정렬하고, 이를 트리구조로 연결해 크기 비교만으로 빠르게 후보군을 좁혀나갈 수 있는 데이터 구조다. B-tree의 각 노드는 키 값과 포인터를 가지는데, 키 값의 좌우에 위치한 포인터는 각각 키 값보다 작은 값과 큰 값을 가진 다음 노드를 가리킨다. 따라서 가장 상위 노드(root)에서부터 키 값 비교를 통해 원하는 값에 도달할 수 있는 것이다. 

100만 개의 튜플을 가진 데이터도 3-4번의 디스크 블록 비교를 통해 검색이 가능하다고 하니 매우 효율적임을 알 수 있다. 하지만 B-tree의 특성상 balance를 유지하기 위해 노드의 분할 및 이동이 자주 발생하는 문제가 있어 잦은 데이터 변경/추가 시 효율이 떨어질 수 있다고.

### 클러스터 인덱스 vs. 세컨더리 인덱스
클러스터 인덱스는 기본키(PK)를 생성하면 자동으로 생성되는 인덱스다. (리프 노드에 해당하는) 전체 튜플을 일정한 사이즈로 묶고(클러스터), 이 클러스터의 시작 주소를 루프 노드에서 참조하는 식이다. 전체 튜플을 검색할 필요없이 일부 값만으로 빠르게 후보군을 좁힐 수 있는 방법이다.

세컨더리 인덱스는 







