---
layout: post
title: "Node.js Architecture and 12 Best Practices for Node.js Development (번역)"
subtitle: "Part 1"
date: 2021-06-18 21:30:13 +0900
background: '../../../img/posts/2021-06-18-nodejs.jpg'
---

원문링크 - [Node.js Architecture and 12 Best Practices for Node.js Development](https://scoutapm.com/blog/nodejs-architecture-and-12-best-practices-for-nodejs-development#abriefhistory)

### Overall

이제 겨우 11년 밖에 되지 않았지만, Node.js는 지난 10년 동안 가장 인기 있는 웹 개발 프레임워크로 부상했습니다. 저는 Javascript의 팬입니다. 이제 Node.js 덕분에 브라우저 바깥에서도 Javascript 코드를 작성해 비동기로 작동하면서, 가볍고, 빠르고, 확장성이 뛰어난 서버-사이드 웹 애플리케이션을 만들 수 있게 되었습니다.

이 게시물에서는 Node.js의 프로그래밍의 두 가지 측면에 대해 이야기하고자 합니다. 첫째는 node js 프레임워크의 내부 메커니즘이고, 둘째는 효율적이고 지속 가능한 애플리케이션을 만들기 위한 node.js best practice에 대한 것입니다.

프레임워크 내부 작동 방식을 이해하려는 노력을 통해 프레임워크 자체에 대한 지식 뿐만 아니라, 프로그래밍 패러다임과 디자인 결정 과정에서의 통찰을 배울 수 있습니다. 이러한 low-level에서의 통찰력과 지식은 시간이 지남에 따라 코드를 작성하는 방식에 반영되고, 속도와 성능을 위해 애플리케이션을 최적화할 수 있는 방법에 대한 이해를 높입니다. 

node.js의 가장 중요한 특징 중 하나는 이벤트 루프 기반의 싱글 스레드 기반으로 작동한다는 사실입니다. 우리는 이 글의 전반부(Part 1)에서 이것을 더 깊이 탐구할 것입니다.

이 게시물의 후반부(Part 2)는 스펙트럼의 다른 쪽 끝을 다룹니다. 신규 Node.js 프로젝트를 시작할 때 알아두면 좋은 12가지 best practice를 알아보겠습니다. 이 부분에서는 전체 아키텍처, 폴더 구조, 모듈화, 클린 코드 작성, dependency 관리 등의 측면에서 견고한 애플리케이션을 만드는 방법에 대해 알아보겠습니다.

이 게시물을 통해 다음 질문에 답하고자 합니다. 

- Node.js는 내부적으로 어떻게 동작하는지?
- Concurrency(동시성)을 어떻게 달성하는지?
- 다른 멀티 스레드 웹 프레임워크와 비교했을 때 어떤지?
- 잘 세팅된 Node.js 프로젝트는 어떻게 생겼는지?
- Node.js 애플리케이션을 세팅할 때, 명심해야 할 점들은?

## node.js의 역사

월드 와이드 웹(WWW)은 약 30년 전에 시작되었습니다. 자바스크립트는 약 25년 전에 태어났으며, PHP도 26년으로 비슷합니다. 반면에 Node.js는 아직 11년 밖에 되지 않았습니다. 상대적으로 짧은 기간임에도 불구하고, Node.js는 전 세계의 개발 조직에서 놀라운 성과를 거두었습니다. 

<img src="../../../img/posts/nodejs_timeline.png" alt="drawing" id="responsive-image"/>

자바스크립트가 출시된 이후, 백엔드에도 자바스크립트를 도입하려는 시도가 있었습니다. 예를 들어, 넷스케이프는 Netscape Livewire와 같은 시도를 하기도 했습니다. 결국 성공하지 못했지만요. 2004년 이후, 웹 2.0의 첫 파도가 시작되었을 때, 자바스크립트는 '현대적인 웹 경험'이라는 비전을 앞세워 많은 관심을 끌었습니다. 자바스크립트는 가장 널리 사용되는 클라이언트 프로그래밍 언어였기 때문에, 많은 브라우저는 최상의 성능을 위해 앞다퉈 최적화된 자바스크립트 엔진을 만들기 위해 경쟁했습니다. 이러한 엔진 중 하나가 바로 Chrome의 V8 엔진이었으며, 이 엔진을 기반으로 Node.js가 제작되게 되죠. 이러한 경쟁의 결과로 자바스크립트는 더욱 번창했고, V8 엔진도 역시 번창하게 되었습니다.

2009년, 가장 적절한 시기에 Node.js가 태어났습니다. 그 이후로 Node.js 개발은 폭발적으로 증가했죠. PHP, Advanced Java등 선점자들이 있었음에도 불구하고, Node.js는 비동기 I/O, 이벤트 기반 아키텍처, 가벼움, 속도, 확장성, 그리고 (가장 인기 있는 프로그래밍 언어인) 자바스크립트를 사용합니다는 사실 덕분에, 많은 애플리케이션에서 선호하는 서버 사이드 선택지로 부상했습니다. 현재 Node.js 서버는 Netflix, Linkedin, Microsoft, GoDaddy, Paypal 등 전 세계 수억 명의 사용자가 있는 애플리케이션 및 엔터프라이즈용 개발에 사용되고 있습니다. Node.js가 얼마나 인기 있는지 대략 귀띔해주자면, npm 패키지 관리자에는 매주 수십억 건의 다운로드가 일어납니다.

Node.js는 방대한 사용자/개발자 커뮤니티 덕분에 활발하게 유지/관리되고 있습니다. 이것은 또한, 만약 여러분이 코드나 일반적인 웹 개발 조언에 도움이 필요하다면, 인터넷을 통해 많은 도움을 얻을 수 있다는 것을 의미하기도 합니다 :)

그럼 Node.js의 내부가 어떻게 작동하는지 알아볼까요?

## Background: node.js는 어떻게 작동하고 있을까?

Node.js는 이벤트 기반 비동기 I/O 프로세싱이 필요한 곳에 널리 사용됩니다. Node.js는 이 동시성(Concurrency)과 비동기성(Asynchronism)의 대부분을 자바스크립트의 '단일 스레드 이벤트 루프 모델'에서 가져옵니다.

Node.js의 대체제로 알려진 다른 웹 개발 도구들(ex. ASP.NET, JSP, Spring)은 '다중 스레드 프로세싱 아키텍처'를 사용하여 동시에 들어오는 클라이언트 요청을 처리할 수 있습니다. 이러한 다중 스레드 모델을 자세히 살펴보고, 이것과 Node.js를 비교해봅시다.

### 멀티 스레드 웹 프레임워크

멀티 스레드 프로세싱 셋업에서 각 서버는 스레드 풀 사용에 제한이 있습니다. 서버는 클라이언트로부터 요청이 들어올 때마다, 풀에서 스레드를 선택하여 클라이언트의 요청에 할당합니다. 이 스레드로 해당 요청과 관련된 모든 처리를 처리하는 식이지요. 이러한 스레드 내부에서는 처리가 순차적(Sequential)이고 동기적(Synchronous)입니다. 즉, 한 번에 한 번의 작업이 수행되지요. 그럼에도 불구하고, 서버에 새롭게 요청이 들어오면, 풀에서 사용 가능한 쓰레드를 가져와 임무를 수행할 수 있습니다.

<img src="../../../img/posts/multi_threaded_architecture.png" alt="drawing" id="responsive-image"/>

이 작업은 모든 스레드가 다 소진될 때까지 계속됩니다. 만약 모든 스레드가 요청에 할당된 경우, 서버는 사용 중인 쓰레드 중 하나가 해제될 때까지 기다리고 있어야 합니다. 이는 결국 애플리케이션을 느리고 비효율적으로 만들죠. 또한, 각 스레드가 가진 동시적 특성(Synchronism)은 blocking code에 의해 속도가 매우 느려질 수 있습니다. 이와 같은 멀티 스레드는 '스레드 간 동기화' 및 '관리' 문제를 야기합니다. 또 여러 스레드가 하나의 리소스를 확보하기를 기다리는 과정에서 데드락이 발생할 위험도 있습니다.

Node.js는 이 문제를 어떻게 해결했을까요?

### 싱글 스레드 이벤트 루프 아키텍쳐

